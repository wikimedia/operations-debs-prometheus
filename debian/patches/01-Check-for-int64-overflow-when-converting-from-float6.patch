From 5cf5bb427a422082b5a484bae2d8c29dd0bb9241 Mon Sep 17 00:00:00 2001
From: beorn7 <beorn@soundcloud.com>
Date: Sat, 5 Nov 2016 00:48:32 +0100
Subject: [PATCH 1/2] Check for int64 overflow when converting from float64

---
 promql/engine.go               | 37 ++++++++++++++++++++++++++-----------
 promql/testdata/operators.test |  5 +++--
 2 files changed, 29 insertions(+), 13 deletions(-)

--- a/promql/engine.go
+++ b/promql/engine.go
@@ -30,6 +30,18 @@
 	"github.com/prometheus/prometheus/util/stats"
 )
 
+const (
+	// The largest SampleValue that can be converted to an int64 without overflow.
+	maxInt64 model.SampleValue = 9223372036854774784
+	// The smallest SampleValue that can be converted to an int64 without underflow.
+	minInt64 model.SampleValue = -9223372036854775808
+)
+
+// convertibleToInt64 returns true if v does not over-/underflow an int64.
+func convertibleToInt64(v model.SampleValue) bool {
+	return v <= maxInt64 && v >= minInt64
+}
+
 // sampleStream is a stream of Values belonging to an attached COWMetric.
 type sampleStream struct {
 	Metric metric.Metric
@@ -575,9 +587,12 @@
 }
 
 // evalInt attempts to evaluate e into an integer and errors otherwise.
-func (ev *evaluator) evalInt(e Expr) int {
+func (ev *evaluator) evalInt(e Expr) int64 {
 	sc := ev.evalScalar(e)
-	return int(sc.Value)
+	if !convertibleToInt64(sc.Value) {
+		ev.errorf("scalar value %v overflows int64", sc.Value)
+	}
+	return int64(sc.Value)
 }
 
 // evalFloat attempts to evaluate e into a float and errors otherwise.
@@ -1012,8 +1027,8 @@
 	case itemPOW:
 		return model.SampleValue(math.Pow(float64(lhs), float64(rhs)))
 	case itemMOD:
-		if int(rhs) != 0 {
-			return model.SampleValue(int(lhs) % int(rhs))
+		if int64(rhs) != 0 && convertibleToInt64(lhs) && convertibleToInt64(rhs) {
+			return model.SampleValue(int64(lhs) % int64(rhs))
 		}
 		return model.SampleValue(math.NaN())
 	case itemEQL:
@@ -1046,8 +1061,8 @@
 	case itemPOW:
 		return model.SampleValue(math.Pow(float64(lhs), float64(rhs))), true
 	case itemMOD:
-		if int(rhs) != 0 {
-			return model.SampleValue(int(lhs) % int(rhs)), true
+		if int64(rhs) != 0 && convertibleToInt64(lhs) && convertibleToInt64(rhs) {
+			return model.SampleValue(int64(lhs) % int64(rhs)), true
 		}
 		return model.SampleValue(math.NaN()), true
 	case itemEQL:
@@ -1089,7 +1104,7 @@
 func (ev *evaluator) aggregation(op itemType, grouping model.LabelNames, without bool, keepCommon bool, param Expr, vec vector) vector {
 
 	result := map[uint64]*groupedAggregation{}
-	var k int
+	var k int64
 	if op == itemTopK || op == itemBottomK {
 		k = ev.evalInt(param)
 		if k < 1 {
@@ -1192,15 +1207,15 @@
 			groupedResult.valuesSquaredSum += s.Value * s.Value
 			groupedResult.groupCount++
 		case itemTopK:
-			if len(groupedResult.heap) < k || groupedResult.heap[0].Value < s.Value || math.IsNaN(float64(groupedResult.heap[0].Value)) {
-				if len(groupedResult.heap) == k {
+			if int64(len(groupedResult.heap)) < k || groupedResult.heap[0].Value < s.Value || math.IsNaN(float64(groupedResult.heap[0].Value)) {
+				if int64(len(groupedResult.heap)) == k {
 					heap.Pop(&groupedResult.heap)
 				}
 				heap.Push(&groupedResult.heap, &sample{Value: s.Value, Metric: s.Metric})
 			}
 		case itemBottomK:
-			if len(groupedResult.reverseHeap) < k || groupedResult.reverseHeap[0].Value > s.Value || math.IsNaN(float64(groupedResult.reverseHeap[0].Value)) {
-				if len(groupedResult.reverseHeap) == k {
+			if int64(len(groupedResult.reverseHeap)) < k || groupedResult.reverseHeap[0].Value > s.Value || math.IsNaN(float64(groupedResult.reverseHeap[0].Value)) {
+				if int64(len(groupedResult.reverseHeap)) == k {
 					heap.Pop(&groupedResult.reverseHeap)
 				}
 				heap.Push(&groupedResult.reverseHeap, &sample{Value: s.Value, Metric: s.Metric})
--- a/promql/testdata/operators.test
+++ b/promql/testdata/operators.test
@@ -54,9 +54,10 @@
 	{job="api-server"} 488
 	{job="app-server"} 40
 
+# int64 overflow on RHS of %.
 eval instant at 50m SUM(http_requests) BY (job) % 2 ^ 3 ^ 2 ^ 2
-	{job="api-server"} 1000
-	{job="app-server"} 2600
+	{job="api-server"} NaN
+	{job="app-server"} NaN
 
 eval instant at 50m COUNT(http_requests) BY (job) ^ COUNT(http_requests) BY (job)
 	{job="api-server"} 256
